{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EA2P : Energy-Aware Application Profiler","text":"<p>EA2P is an energy profiling tool designed to accurately measure the energy consumption of various computer devices, including RAM, CPU, and GPU. It supports multiple hardware vendors such as Nvidia, AMD, and Intel, allowing comprehensive energy measurements across different systems. The particularity of the tool is the flexibility over target device selection feature and the support for AMD devices energy measurement.  </p> <p>Please consult the documentation or support resources for your specific CPU and GPU models to find the appropriate configuration and instructions for monitoring energy consumption. Keep in mind that the availability of such features may vary depending on your hardware.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Granular Results: Provides detailed and fine-grained energy measurements per device and power domains, particularly for Intel-based components, offering a comprehensive understanding of energy consumption across the system.</p> </li> <li> <p>Multi-Device Measurement: Supports measurement for a variety of devices including RAM, AMD GPU &amp; CPU, Nvidia GPU, and Intel CPU. This comprehensive coverage allows for holistic energy analysis.</p> </li> <li> <p>Code Instrumentation: Offers an API for code instrumentation as well as a Command Line Interface (CLI) for flexible usage, enabling both direct integration into applications and standalone usage for measurement purposes.</p> </li> <li> <p>Sampling Frequency Control: Provides users with the option to set the sampling frequency, allowing for customizable energy measurement intervals based on specific requirements and precision needs.</p> </li> <li> <p>Automatic Device Detection: Automatically detects device vendors and selects appropriate commands, simplifying usage for users and ensuring compatibility across different hardware configurations.</p> </li> <li> <p>Selective Device Measurement: Allows users to select specific devices for measurement, offering the flexibility to focus on a subset of the system components, which can be advantageous for targeted analysis.</p> </li> <li>Multi-node Measurement: Provides users with the ability to monitor energy consumption across multiple nodes in traditional HPC or cluster computing environments. A comprehensive energy-per-rank (node) breakdown and total energy consumption for each device type in a homogeneous node system are provided to you.</li> <li>Docker support: To further enhance the usability and portability of the energy measurement tool, it has been containerized using Docker.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>RAPL (Running Average Power Limit): it is a feature found in modern Intel processors that allows monitoring and controlling power consumption. RAPL provides a set of registers that can be used to read power-related information, such as power consumption, and to set power limits for the processor. If it is not installed, you can run the code below: <pre><code>sudo apt install msr-tools   # For Ubuntu/Debian\n</code></pre></li> <li>ROCm-SMI : ROCm-SMI (Radeon Open Compute System Management Interface) is a command-line interface developed by AMD as part of the ROCm (Radeon Open Compute) software stack. It provides a set of tools for managing and monitoring AMD GPUs kernels that are compatible with the ROCm platform. So you should install the ROCm stack for GPU profiling if it is not installed on your AMD GPU platform : install ROCm</li> <li>Nvidia-SMI : Nvidia-SMI(Nvidia System Management Interface) is the ROCm-SMI alternative if you are working with Nvidia GPU. Generally it comes with Nvidia drivers installation : install Nividia Drivers</li> <li>Perf tools : It is used to monitore energy for AMD CPU since we did not yet find a way to access the AMD RAPL files in Linux systems.</li> <li>MPI library (for multi-node profiling) : Ensure that you have an MPI implementation installed on your system. Common implementations include MPICH and OpenMPI.  <pre><code>sudo apt-get install openmpi-bin openmpi-common libopenmpi-dev   # For Ubuntu/Debian as example of installation\n</code></pre> And use the following to run the instrumented code : <pre><code>mpiexec -n 4 python my_instrumented_mpi_app.py   # You can change mpiexec with mpirun depending of your MPI installation.\n</code></pre></li> </ul>"},{"location":"developper_guide/","title":"Energy-Aware Profiling Tool Developer Guide","text":"<p>Welcome to the Developer Guide for our Energy-Aware Profiling Tool! This guide will walk you through the process of cloning the repository, customizing it for your needs, and adding new file modules to support additional device measurements.</p>"},{"location":"developper_guide/#cloning-the-repository","title":"Cloning the Repository","text":"<p>To get started, follow these steps to clone the repository:</p> <ol> <li>Open a terminal or command prompt.</li> <li>Navigate to the directory where you want to clone the repository.</li> <li>Run the following command: <pre><code>git clone https://github.com/HPC-CRI/EA2P\n</code></pre></li> </ol>"},{"location":"developper_guide/#customizing-the-tool","title":"Customizing the Tool","text":"<p>After cloning the repository, you may want to customize it according to your specific requirements. Here are some common customization tasks:</p>"},{"location":"developper_guide/#configuration","title":"Configuration","text":"<ol> <li>Modify the default configuration file <code>config_energy.json</code> located in the <code>ea2p/src</code> directory to adjust settings such as sampling interval, measurement thresholds, etc.</li> </ol>"},{"location":"developper_guide/#visualization-output","title":"Visualization output","text":"<ol> <li>Customize the output components named <code>__record_data_to_file</code> in the <code>ea2p/src/power_meter.py</code> file to tailor the output representation of energy profiling data as CSV, excel, json saving.</li> </ol>"},{"location":"developper_guide/#rapl-path-for-intel-users","title":"RAPL path for Intel Users","text":"<ol> <li>Customize the intel RAPL directory to suit your energy profiling needs depending of your architecture using <code>ea2p/src/utils.py</code> files and set some others system configurations.</li> </ol>"},{"location":"developper_guide/#adding-a-new-file-module","title":"Adding a New File Module","text":"<p>If you need to support new device measurements, you can add a new file module to handle the data. Follow these steps:</p> <ol> <li> <p>Create a new Python file in the <code>ea2p/src/</code> directory for your new module. For example, <code>FPGA_module.py</code>.</p> </li> <li> <p>Implement the necessary functions to parse and process the data from the new device.</p> </li> <li> <p>Update the <code>__init__.py</code> file in the <code>ea2p/src</code> directory to include your new module. For example:</p> </li> </ol> <pre><code>from .FPGA_module import XilinxPower\n</code></pre> <ol> <li> <p>Configure the <code>ea2p/src/wrapper.py</code> module to support your energy module. Especially the <code>get_power_consumption</code> function. Also, adapt the <code>__set_power</code> method in the same file to support auto-detection of your devices and make some initializations eventually.</p> </li> <li> <p>Finally, use the <code>PowerMeter</code> instance to profile your application by specifying your device in the list of devices in configuration the file. </p> </li> </ol>"},{"location":"install/","title":"Installation and Usage","text":""},{"location":"install/#installation","title":"Installation","text":"<p>To install EA2P, simply use pip:</p> <pre><code>pip install EA2P\n</code></pre>"},{"location":"install/#usage","title":"Usage","text":"<p>Warning : For any usage, you should authorize the access. Commands bellow could be used especially for perf (for AMD CPU), powercap(for Intel) and dmidecode (for DRAM): <pre><code>sudo sh -c 'echo -1 &gt;/proc/sys/kernel/perf_event_paranoid'\nsudo chmod -R a+r /sys/firmware/dmi/tables\nsudo chmod -R a+r /sys/class/powercap/intel-rapl\n</code></pre></p> <p>Note : Some examples might require to install specific libraries like TensorFlow or Pytorch as part of the application devellopement.</p>"},{"location":"install/#command-line-interface-cli","title":"Command-Line Interface (CLI)","text":"<p>Run the following command to start profiling: the file can be found in the \"examples\" folder of this repository. my_application can be any command line program that can run standalone like a compiled C/C++ program or python program with arguments.</p> <pre><code>python ea2p_cli.py my_application\n</code></pre>"},{"location":"install/#code-instrumentation","title":"Code Instrumentation","text":"<p>Add annotations to your code to measure energy consumption.  <pre><code>from ea2p import PowerMeter\nconfig_path = \u201cconfig.csv\u201d #set the configuration file for flexibility\npower_meter = PowerMeter(config_path)\n\n# Annotate the code section you want to measure. \"package\" and \"algorithm\" params are required. \n@power_meter.measure_power(package=\"time\", algorithm=\"sleep\",)\ndef test_sleep(interval):\n   time.sleep(interval)\n# runing\ntest_sleep(180)         \n</code></pre></p>"},{"location":"install/#using-context-manager","title":"Using context manager","text":"<pre><code>from ea2p import PowerMeter\n\nwith PowerMeter() as meter:\n   time.sleep(180)      \n</code></pre>"},{"location":"install/#using-startstop","title":"Using start/stop","text":"<pre><code>from ea2p import PowerMeter\nconfig_path = \u201cconfig.csv\u201d #set the configuration file for flexibility\npower_meter = PowerMeter(config_path)\n\nmeter.start_measure()\ntime.sleep(180)\nmeter.stop_measure()        \n</code></pre>"},{"location":"install/#configuration-file","title":"Configuration file","text":"<p>EA2P allows configuration for specific settings such as devices list, sampling frequency, and more. Configuration can be done via a json configuration file. <pre><code>{\n    \"devices_list\": \"cpu, gpu, ram\",\n    \"sampling_freq\": 1.0,\n    \"energy_unit\": \"J\"\n}\n</code></pre></p> <p>For more examples of how to use the profiler, clone the original repository from Github : https://github.com/HPC-CRI/EA2P and run examples under <code>ea2p/examples</code> directory or visit the API reference and developper guide : EA2P documentation.</p>"},{"location":"about/Contribution/","title":"Contributing","text":"<p>We welcome contributions to EA2P! Please check the contribution guidelines for details on how to contribute to this project.</p>"},{"location":"about/Contribution/#license","title":"License","text":"<p>EA2P is licensed under the MIT License. See the LICENSE file for more details.</p>"},{"location":"about/Contribution/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>This research was supported by The Transition Institute 1.5 driven by \u00c9cole des Mines de Paris - PSL</li> <li>CRI (Centre de recherche en Informatique) - Mines Paris - PSL</li> </ul>"},{"location":"about/Contribution/#contact","title":"Contact","text":"<p>For any queries, support, or feedback, feel free to reach out via email or through our website.</p>"},{"location":"about/about/","title":"About us","text":""},{"location":"about/license/","title":"License","text":""},{"location":"about/release-notes/","title":"Release Note","text":""},{"location":"api_documentation/PowerMeter/","title":"ea2p.PowerMeter","text":""},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter","title":"PowerMeter","text":"<pre><code>PowerMeter(\n    project_name=\"test_project\",\n    output_filepath=None,\n    config_file=None,\n    output_format=\"csv\",\n    print_to_cli=True,\n)\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter--powermeter","title":"PowerMeter","text":"<p>The Main Python class for monitoring power consumption during the execution of an algorithm.</p> <p>Attributes:</p> <ul> <li> <code>DATETIME_FORMAT</code>               (<code>str</code>)           \u2013            <p>The format for datetime objects.</p> </li> <li> <code>DEFAULT_CONFIG_FILE</code>               (<code>str</code>)           \u2013            <p>The default configuration file name to use for wrapper.</p> </li> <li> <code>DEFAULT_OUTPUT_FILEPATH</code>               (<code>str</code>)           \u2013            <p>The default output file path to save results.</p> </li> <li> <code>LOGGING_FILE</code>               (<code>str</code>)           \u2013            <p>The filename for the experimentation logging file.</p> </li> <li> <code>project_name</code>               (<code>str</code>)           \u2013            <p>Name of the experimentation project.</p> </li> <li> <code>config_file</code>               (<code>str</code>)           \u2013            <p>Path to the configuration file for the wrapper initialisation.</p> </li> <li> <code>output_filepath</code>               (<code>str</code>)           \u2013            <p>Path to the output file for results of profiling.</p> </li> <li> <code>output_format</code>               (<code>str</code>)           \u2013            <p>Format for the output file (e.g. csv).</p> </li> <li> <code>print_to_cli</code>               (<code>bool</code>)           \u2013            <p>Flag to print the result of measurement in Terminal at the end (default True).</p> </li> <li> <code>power</code>               (<code>PowerWrapper</code>)           \u2013            <p>Instance of PowerWrapper class for power measurement.</p> </li> <li> <code>used_package</code>               (<code>str</code>)           \u2013            <p>Name of the package of algorithm to profile during power measurement.</p> </li> <li> <code>used_algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the profiled algorithm for power measurement.</p> </li> <li> <code>used_algorithm_description</code>               (<code>str</code>)           \u2013            <p>Description of the algorithm used during power measurement.</p> </li> <li> <code>logging_filename</code>               (<code>str</code>)           \u2013            <p>Path to the logging file of experiment.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>measure_power</code>             \u2013              <p>Decorator to measure power consumption during the execution of a function.</p> </li> <li> <code>__set_used_arguments</code>             \u2013              <p>Set the arguments used during power measurement.</p> </li> <li> <code>__call__</code>             \u2013              <p>Set the arguments used during power measurement using a decorator syntax.</p> </li> <li> <code>__enter__</code>             \u2013              <p>Enter method for context manager. Starts power measurement.</p> </li> <li> <code>__exit__</code>             \u2013              <p>Exit method for context manager. Stops power measurement.</p> </li> <li> <code>start_measure</code>             \u2013              <p>Start measuring power consumption.</p> </li> <li> <code>stop_measure</code>             \u2013              <p>Stop measuring power consumption.</p> </li> <li> <code>__record_data_to_file</code>             \u2013              <p>Record power data to a file.</p> </li> <li> <code>__log_records</code>             \u2013              <p>Log recorded power data.</p> </li> </ul> <p>Initialize the PowerMeter instance.</p> <p>Parameters:</p> <ul> <li> <code>config_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the configuration file.</p> </li> <li> <code>project_name</code>               (<code>str</code>, default:                   <code>'test_project'</code> )           \u2013            <p>Name of the project.</p> </li> <li> <code>output_filepath</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the output file.</p> </li> <li> <code>output_format</code>               (<code>str</code>, default:                   <code>'csv'</code> )           \u2013            <p>Format for the output file.</p> </li> <li> <code>print_to_cli</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>To print the result of measurement in Terminal at the end</p> </li> </ul> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __init__(self, project_name=\"test_project\", output_filepath=None, config_file=None, output_format=\"csv\", print_to_cli=True):\n    \"\"\"\n    Initialize the PowerMeter instance.\n\n    Parameters:\n        config_file (str): Path to the configuration file.\n        project_name (str): Name of the project.\n        output_filepath (str): Path to the output file.\n        output_format (str): Format for the output file.\n        print_to_cli (bool): To print the result of measurement in Terminal at the end\n    \"\"\"\n\n    self.project_name = project_name\n    self.config_file = Path(config_file) if config_file else Path.cwd() / self.DEFAULT_CONFIG_FILE\n    self.output_filepath = Path(output_filepath) if output_filepath else Path.cwd() / self.DEFAULT__OUTPUT_FILEPATH\n    self.output_format = output_format\n    self.print_to_cli = print_to_cli\n\n    self.power = PowerWrapper(self.config_file)\n\n    self.used_package = \"\"\n    self.used_algorithm = \"\"\n    self.used_algorithm_description = \"\"\n\n    self.logging_filename = PACKAGE_PATH / self.LOGGING_FILE\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.__call__","title":"__call__","text":"<pre><code>__call__(package, algorithm, algorithm_description='')\n</code></pre> <p>Set the arguments used during power measurement using a decorator syntax.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __call__(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Set the arguments used during power measurement using a decorator syntax.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    self.__set_used_arguments(package, algorithm, algorithm_description=algorithm_description)\n    return self\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Enter method for context manager. Starts power measurement.</p> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Enter method for context manager. Starts power measurement.\n    \"\"\"\n    self.start_measure(\n        self.used_package,\n        self.used_algorithm,\n        algorithm_description=self.used_algorithm_description,\n    )\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.__exit__","title":"__exit__","text":"<pre><code>__exit__(exit_type, value, traceback)\n</code></pre> <p>Exit method for context manager. Stops power measurement.</p> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __exit__(self, exit_type, value, traceback):\n    \"\"\"\n    Exit method for context manager. Stops power measurement.\n    \"\"\"\n    self.stop_measure()\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.__log_records","title":"__log_records","text":"<pre><code>__log_records(\n    recorded_power,\n    algorithm=\"\",\n    package=\"\",\n    algorithm_description=\"\",\n)\n</code></pre> <p>Log recorded power data.</p> <p>Parameters:</p> <ul> <li> <code>recorded_power</code>               (<code>DataFrame</code>)           \u2013            <p>Recorded power data.</p> </li> <li> <code>package</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __log_records(self, recorded_power, algorithm=\"\", package=\"\", algorithm_description=\"\"):\n    \"\"\"\n    Log recorded power data.\n\n    Parameters:\n        recorded_power (DataFrame): Recorded power data.\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    payload_prefix = {\n        \"Project Name\": self.project_name,\n        \"Datetime\": datetime.datetime.now().strftime(self.DATETIME_FORMAT)\n    }\n    payload_sufix = {\n        \"Package\": package,\n        \"Algorithm\": algorithm,\n        \"Algorithm's parameters\": algorithm_description,\n    }\n    written = self.__record_data_to_file(\n        pd.concat(\n            [pd.DataFrame(payload_prefix, index=[0]), recorded_power, pd.DataFrame(payload_sufix, index=[0])],\n            axis=1,\n        )\n    )\n    LOGGER.info(\"Recorded into a file? %s\", written)\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.__record_data_to_file","title":"__record_data_to_file","text":"<pre><code>__record_data_to_file(data)\n</code></pre> <p>Record power data to a file.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>Power data to be recorded.</p> </li> </ul> <p>Returns:     True if recording is successful, False otherwise.</p> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __record_data_to_file(self, data):\n    \"\"\"\n    Record power data to a file.\n\n    Parameters:\n        data (DataFrame): Power data to be recorded.\n    Returns:\n        True if recording is successful, False otherwise.\n    \"\"\"\n    try:\n        if self.output_filepath.exists():\n            data.to_csv(self.output_filepath, mode=\"a\", index=False, header=False)\n        else:\n            data.to_csv(self.output_filepath, index=False)\n        return True\n    except Exception as e:\n        LOGGER.error(\"Error during the CSV writing process: %s\", str(e))\n        LOGGER.error(traceback.format_exc())\n        return False\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.__set_used_arguments","title":"__set_used_arguments","text":"<pre><code>__set_used_arguments(\n    package, algorithm, algorithm_description=\"\"\n)\n</code></pre> <p>Set the arguments used during power measurement.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def __set_used_arguments(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Set the arguments used during power measurement.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    self.used_package = package\n    self.used_algorithm = algorithm\n    self.used_algorithm_description = algorithm_description\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.measure_power","title":"measure_power","text":"<pre><code>measure_power(package, algorithm, algorithm_description='')\n</code></pre> <p>Decorator to measure power consumption during the execution of a function.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> <p>Returns:     Decorator function.</p> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def measure_power(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Decorator to measure power consumption during the execution of a function.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n    Returns:\n        Decorator function.\n    \"\"\"\n    if not algorithm or not package:\n        raise SyntaxError(\n            \"Please input a description for the function you are trying \"\n            \"to monitor. Pass in the algorithm and the package you are \"\n            \"trying to monitor\"\n        )\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            self.start_measure(\n                package,\n                algorithm,\n                algorithm_description=algorithm_description,\n            )\n            try:\n                results = func(*args, **kwargs)\n            finally:\n                self.stop_measure()\n            return results\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.start_measure","title":"start_measure","text":"<pre><code>start_measure(package, algorithm, algorithm_description='')\n</code></pre> <p>Start measuring power consumption.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def start_measure(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Start measuring power consumption.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    self.power.start()\n    self.__set_used_arguments(\n        package,\n        algorithm,\n        algorithm_description=algorithm_description,\n    )\n</code></pre>"},{"location":"api_documentation/PowerMeter/#ea2p.src.power_meter.PowerMeter.stop_measure","title":"stop_measure","text":"<pre><code>stop_measure()\n</code></pre> <p>Stop measuring power consumption.</p> Source code in <code>ea2p/src/power_meter.py</code> <pre><code>def stop_measure(self):\n    \"\"\"\n    Stop measuring power consumption.\n    \"\"\"\n    self.power.stop()\n\n    if self.print_to_cli :\n        print(\"Energy report for the experiment : \\n\\n\")\n        print(self.power.record)\n\n    self.__log_records(\n        self.power.record,\n        algorithm=self.used_algorithm,\n        package=self.used_package,\n        algorithm_description=self.used_algorithm_description,\n    )\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/","title":"ea2p.PowerMeterMPI","text":""},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI","title":"PowerMeterMPI","text":"<pre><code>PowerMeterMPI(\n    project_name=\"test_project\",\n    output_filepath=None,\n    config_file=None,\n    output_format=\"csv\",\n    print_to_cli=True,\n)\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI--powermeter","title":"PowerMeter","text":"<p>Multi-node capable class for monitoring power consumption.</p> <p>Attributes:</p> <ul> <li> <code>DATETIME_FORMAT</code>               (<code>str</code>)           \u2013            <p>The format for datetime objects.</p> </li> <li> <code>DEFAULT_CONFIG_FILE</code>               (<code>str</code>)           \u2013            <p>The default configuration file name to use for wrapper.</p> </li> <li> <code>DEFAULT_OUTPUT_FILEPATH</code>               (<code>str</code>)           \u2013            <p>The default output file path to save results.</p> </li> <li> <code>LOGGING_FILE</code>               (<code>str</code>)           \u2013            <p>The filename for the experimentation logging file.</p> </li> <li> <code>project_name</code>               (<code>str</code>)           \u2013            <p>Name of the experimentation project.</p> </li> <li> <code>config_file</code>               (<code>str</code>)           \u2013            <p>Path to the configuration file for the wrapper initialisation.</p> </li> <li> <code>output_filepath</code>               (<code>str</code>)           \u2013            <p>Path to the output file for results of profiling.</p> </li> <li> <code>output_format</code>               (<code>str</code>)           \u2013            <p>Format for the output file (e.g. csv).</p> </li> <li> <code>print_to_cli</code>               (<code>bool</code>)           \u2013            <p>Flag to print the result of measurement in Terminal at the end (default True).</p> </li> <li> <code>power</code>               (<code>PowerWrapper</code>)           \u2013            <p>Instance of PowerWrapper class for power measurement.</p> </li> <li> <code>used_package</code>               (<code>str</code>)           \u2013            <p>Name of the package of algorithm to profile during power measurement.</p> </li> <li> <code>used_algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the profiled algorithm for power measurement.</p> </li> <li> <code>used_algorithm_description</code>               (<code>str</code>)           \u2013            <p>Description of the algorithm used during power measurement.</p> </li> <li> <code>logging_filename</code>               (<code>str</code>)           \u2013            <p>Path to the logging file of experiment.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>measure_power</code>             \u2013              <p>Decorator to measure power consumption during the execution of a function.</p> </li> <li> <code>__set_used_arguments</code>             \u2013              <p>Set the arguments used during power measurement.</p> </li> <li> <code>__call__</code>             \u2013              <p>Set the arguments used during power measurement using a decorator syntax.</p> </li> <li> <code>__enter__</code>             \u2013              <p>Enter method for context manager. Starts power measurement.</p> </li> <li> <code>__exit__</code>             \u2013              <p>Exit method for context manager. Stops power measurement.</p> </li> <li> <code>start_measure</code>             \u2013              <p>Start measuring power consumption.</p> </li> <li> <code>stop_measure</code>             \u2013              <p>Stop measuring power consumption.</p> </li> <li> <code>__record_data_to_file</code>             \u2013              <p>Record power data to a file.</p> </li> <li> <code>__log_records</code>             \u2013              <p>Log recorded power data.</p> </li> </ul> <p>Initialize the PowerMeter instance. This initialization is done on every node of the system.</p> <p>Parameters:</p> <ul> <li> <code>config_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the configuration file.</p> </li> <li> <code>project_name</code>               (<code>str</code>, default:                   <code>'test_project'</code> )           \u2013            <p>Name of the project.</p> </li> <li> <code>output_filepath</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the output file.</p> </li> <li> <code>output_format</code>               (<code>str</code>, default:                   <code>'csv'</code> )           \u2013            <p>Format for the output file.</p> </li> <li> <code>print_to_cli</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>To print the result of measurement in Terminal at the end</p> </li> </ul> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __init__(self, project_name=\"test_project\", output_filepath=None, config_file=None, output_format=\"csv\", print_to_cli=True):\n    \"\"\"\n    Initialize the PowerMeter instance. This initialization is done on every node of the system.\n\n    Parameters:\n        config_file (str): Path to the configuration file.\n        project_name (str): Name of the project.\n        output_filepath (str): Path to the output file.\n        output_format (str): Format for the output file.\n        print_to_cli (bool): To print the result of measurement in Terminal at the end\n    \"\"\"\n    self.project_name = project_name\n    self.config_file = Path(config_file) if config_file else Path.cwd() / self.DEFAULT_CONFIG_FILE\n    self.output_filepath = Path(output_filepath) if output_filepath else Path.cwd() / self.DEFAULT__OUTPUT_FILEPATH\n    self.output_format = output_format\n    self.print_to_cli = print_to_cli\n\n    self.power = PowerWrapper(self.config_file)\n\n    self.used_package = \"\"\n    self.used_algorithm = \"\"\n    self.used_algorithm_description = \"\"\n\n    self.logging_filename = PACKAGE_PATH / self.LOGGING_FILE\n\n    # Initialize MPI\n    self.comm = MPI.COMM_WORLD\n    self.rank = self.comm.Get_rank()\n    self.size = self.comm.Get_size()\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.__call__","title":"__call__","text":"<pre><code>__call__(package, algorithm, algorithm_description='')\n</code></pre> <p>Set the arguments used during power measurement using a decorator syntax.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __call__(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Set the arguments used during power measurement using a decorator syntax.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    self.__set_used_arguments(package, algorithm, algorithm_description=algorithm_description)\n    return self\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre> <p>Enter method for context manager. Starts power measurement.</p> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Enter method for context manager. Starts power measurement.\n    \"\"\"\n    self.start_measure(\n        self.used_package,\n        self.used_algorithm,\n        algorithm_description=self.used_algorithm_description,\n    )\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.__exit__","title":"__exit__","text":"<pre><code>__exit__(exit_type, value, traceback)\n</code></pre> <p>Exit method for context manager. Stops power measurement on a rank.</p> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __exit__(self, exit_type, value, traceback):\n    \"\"\"\n    Exit method for context manager. Stops power measurement on a rank.\n    \"\"\"\n    self.stop_measure()\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.__log_records","title":"__log_records","text":"<pre><code>__log_records(\n    recorded_power,\n    algorithm=\"\",\n    package=\"\",\n    algorithm_description=\"\",\n)\n</code></pre> <p>Log recorded power data.</p> <p>Parameters:</p> <ul> <li> <code>recorded_power</code>               (<code>DataFrame</code>)           \u2013            <p>Recorded power data.</p> </li> <li> <code>package</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __log_records(self, recorded_power, algorithm=\"\", package=\"\", algorithm_description=\"\"):\n    \"\"\"\n    Log recorded power data.\n\n    Parameters:\n        recorded_power (DataFrame): Recorded power data.\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    payload_prefix = {\n        \"Project Name\": self.project_name,\n        \"Datetime\": datetime.datetime.now().strftime(self.DATETIME_FORMAT)\n    }\n    payload_suffix = {\n        \"Package\": package,\n        \"Algorithm\": algorithm,\n        \"Algorithm's parameters\": algorithm_description,\n    }\n    written = self.__record_data_to_file(\n        pd.concat(\n            [pd.DataFrame(payload_prefix, index=[0]), recorded_power, pd.DataFrame(payload_suffix, index=[0])],\n            axis=1,\n        )\n    )\n    LOGGER.info(\"Recorded into a file? %s\", written)\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.__record_data_to_file","title":"__record_data_to_file","text":"<pre><code>__record_data_to_file(data)\n</code></pre> <p>Record power data to a file.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>DataFrame</code>)           \u2013            <p>Power data to be recorded.</p> </li> </ul> <p>Returns:     True if recording is successful, False otherwise.</p> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __record_data_to_file(self, data):\n    \"\"\"\n    Record power data to a file.\n\n    Parameters:\n        data (DataFrame): Power data to be recorded.\n    Returns:\n        True if recording is successful, False otherwise.\n    \"\"\"\n    try:\n        if self.output_filepath.exists():\n            data.to_csv(self.output_filepath, mode=\"a\", index=False, header=False)\n        else:\n            data.to_csv(self.output_filepath, index=False)\n        return True\n    except Exception as e:\n        LOGGER.error(\"Error during the CSV writing process: %s\", str(e))\n        LOGGER.error(traceback.format_exc())\n        return False\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.__set_used_arguments","title":"__set_used_arguments","text":"<pre><code>__set_used_arguments(\n    package, algorithm, algorithm_description=\"\"\n)\n</code></pre> <p>Set the arguments used during power measurement.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def __set_used_arguments(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Set the arguments used during power measurement.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    self.used_package = package\n    self.used_algorithm = algorithm\n    self.used_algorithm_description = algorithm_description\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.measure_power","title":"measure_power","text":"<pre><code>measure_power(package, algorithm, algorithm_description='')\n</code></pre> <p>Decorator to measure power consumption during the execution of a function.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> <p>Returns:     Decorator function.</p> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def measure_power(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Decorator to measure power consumption during the execution of a function.\n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n    Returns:\n        Decorator function.\n    \"\"\"\n    if not algorithm or not package:\n        raise SyntaxError(\n            \"Please input a description for the function you are trying \"\n            \"to monitor. Pass in the algorithm and the package you are \"\n            \"trying to monitor\"\n        )\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            self.start_measure(\n                package,\n                algorithm,\n                algorithm_description=algorithm_description,\n            )\n            try:\n                results = func(*args, **kwargs)\n            finally:\n                self.stop_measure()\n            return results\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.start_measure","title":"start_measure","text":"<pre><code>start_measure(package, algorithm, algorithm_description='')\n</code></pre> <p>Start measuring power consumption on each MPI rank. </p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package name of the algorithm to profile.</p> </li> <li> <code>algorithm</code>               (<code>str</code>)           \u2013            <p>Name of the algorithm to profile in the list of instruction of the decorated function.</p> </li> <li> <code>algorithm_description</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).</p> </li> </ul> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def start_measure(self, package, algorithm, algorithm_description=\"\"):\n    \"\"\"\n    Start measuring power consumption on each MPI rank. \n\n    Parameters:\n        package (str): Package name of the algorithm to profile.\n        algorithm (str): Name of the algorithm to profile in the list of instruction of the decorated function.\n        algorithm_description (str): Description of the profiled algorithm acording to the experimental setup or tesbet details (eg, dataset used, epochs for training, batch size, etc...).\n\n    \"\"\"\n    self.power.start()\n    self.__set_used_arguments(\n        package,\n        algorithm,\n        algorithm_description=algorithm_description,\n    )\n</code></pre>"},{"location":"api_documentation/PowerMeterMPI/#ea2p.src.power_meter_mpi.PowerMeterMPI.stop_measure","title":"stop_measure","text":"<pre><code>stop_measure()\n</code></pre> <p>Stop measuring power consumption and gather results from all MPI processes.</p> Source code in <code>ea2p/src/power_meter_mpi.py</code> <pre><code>def stop_measure(self):\n    \"\"\"\n    Stop measuring power consumption and gather results from all MPI processes.\n    \"\"\"\n    self.power.stop()\n    local_record = self.power.record\n\n    # Add rank number to local record\n    if local_record is not None:\n        local_record['Rank'] = self.rank\n\n    # Gathering data from all processes\n    global_record = self.comm.gather(local_record, root=0)\n\n    if self.rank == 0:\n        # Filter out None values in case some processes had no data\n        global_record = [record for record in global_record if record is not None]\n\n        if global_record:\n            # Concatenate data from all processes, preserving the original ranks\n            global_record = pd.concat(global_record, ignore_index=True)\n\n            # Compute total energy and add the 'Rank' column for the total row\n            total_energy = global_record.sum(numeric_only=True)\n            total_energy['Rank'] = 'Total'\n            total_energy_row = pd.DataFrame([total_energy], columns=global_record.columns)\n            total_energy_row = total_energy_row.round(5)\n\n            # Append the total row to the global record\n            global_record = pd.concat([global_record, total_energy_row], ignore_index=True)\n\n            # Print the result if required\n            if self.print_to_cli:\n                print(\"Energy report for the experiment:\\n\")\n                print(global_record)\n\n            # Log the results\n            self.__log_records(\n                global_record,\n                algorithm=self.used_algorithm,\n                package=self.used_package,\n                algorithm_description=self.used_algorithm_description,\n            )\n        else:\n            print(\"No data was collected from the processes.\")\n</code></pre>"},{"location":"api_documentation/amd/","title":"ea2p.amd","text":""},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu","title":"PowerAmdCpu","text":"<pre><code>PowerAmdCpu()\n</code></pre> Source code in <code>ea2p/src/amd.py</code> <pre><code>def __init__(self):\n    self.logging_process = None\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu.parse_log","title":"parse_log","text":"<pre><code>parse_log()\n</code></pre> <p>Parse the AMD CPU power log file to energy values per package and per nodes. Returns:         DataFrame containing energy data.</p> Source code in <code>ea2p/src/amd.py</code> <pre><code>def parse_log(self):\n    \"\"\"\n    Parse the AMD CPU power log file to energy values per package and per nodes.\n    Returns:\n    \tDataFrame containing energy data.\n    \"\"\"\n    with open(r\"%s\" % AMDPOWERLOG_FILENAME, 'r') as fp:\n        data = fp.read()\n    data = data.replace(\",\", \".\")\n    p = re.compile(r'([\\d]+.+[\\d.]+)\\s+Joules power/energy-pkg/')\n    data = p.findall(data)\n    data = [d.replace(\" \", \"\") for d in data]\n    for i in range(len(data)):\n        # Count the total number of periods\n        total_periods = data[i].count('.')\n        # If there are more than one periods, replace all but the last one\n        if total_periods &gt; 1:\n            # Remove all periods except the last one\n            data[i] = data[i].replace('.', '', total_periods - 1)\n    cols = [\"package \" + str(i) for i in range(len(data))]\n    energy = pd.DataFrame(np.array([data]), columns=cols)\n    energy = energy.astype(\"float32\")\n    energy = energy / 3600\n    return energy\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the measure process using Linux Perf Tools through perf stat system wide sampling</p> Source code in <code>ea2p/src/amd.py</code> <pre><code>def start(self):\n    \"\"\"\n    Start the measure process using Linux Perf Tools through perf stat system wide sampling\n    \"\"\"\n    if self.logging_process is not None:\n        self.stop()\n\n    self.logging_process = subprocess.Popen(\n        [\n            \"perf\",\n            \"stat\",\n            \"-e\",\n            \"power/energy-pkg/\",\n            \"-a\",\n            \"--per-node\",\n            \"-o\",\n            str(AMDPOWERLOG_FILENAME),\n        ]\n    )\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the measure process if started. A signal is send to the logging process to stop measurements</p> Source code in <code>ea2p/src/amd.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stop the measure process if started. A signal is send to the logging process to stop measurements\n    \"\"\"\n    self.logging_process.send_signal(signal.SIGINT)\n    self.logging_process = None\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu","title":"PowerAmdCpu","text":"<pre><code>PowerAmdCpu()\n</code></pre> Source code in <code>ea2p/src/amd.py</code> <pre><code>def __init__(self):\n    self.logging_process = None\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu.parse_log","title":"parse_log","text":"<pre><code>parse_log()\n</code></pre> <p>Parse the AMD CPU power log file to energy values per package and per nodes. Returns:         DataFrame containing energy data.</p> Source code in <code>ea2p/src/amd.py</code> <pre><code>def parse_log(self):\n    \"\"\"\n    Parse the AMD CPU power log file to energy values per package and per nodes.\n    Returns:\n    \tDataFrame containing energy data.\n    \"\"\"\n    with open(r\"%s\" % AMDPOWERLOG_FILENAME, 'r') as fp:\n        data = fp.read()\n    data = data.replace(\",\", \".\")\n    p = re.compile(r'([\\d]+.+[\\d.]+)\\s+Joules power/energy-pkg/')\n    data = p.findall(data)\n    data = [d.replace(\" \", \"\") for d in data]\n    for i in range(len(data)):\n        # Count the total number of periods\n        total_periods = data[i].count('.')\n        # If there are more than one periods, replace all but the last one\n        if total_periods &gt; 1:\n            # Remove all periods except the last one\n            data[i] = data[i].replace('.', '', total_periods - 1)\n    cols = [\"package \" + str(i) for i in range(len(data))]\n    energy = pd.DataFrame(np.array([data]), columns=cols)\n    energy = energy.astype(\"float32\")\n    energy = energy / 3600\n    return energy\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the measure process using Linux Perf Tools through perf stat system wide sampling</p> Source code in <code>ea2p/src/amd.py</code> <pre><code>def start(self):\n    \"\"\"\n    Start the measure process using Linux Perf Tools through perf stat system wide sampling\n    \"\"\"\n    if self.logging_process is not None:\n        self.stop()\n\n    self.logging_process = subprocess.Popen(\n        [\n            \"perf\",\n            \"stat\",\n            \"-e\",\n            \"power/energy-pkg/\",\n            \"-a\",\n            \"--per-node\",\n            \"-o\",\n            str(AMDPOWERLOG_FILENAME),\n        ]\n    )\n</code></pre>"},{"location":"api_documentation/amd/#ea2p.src.amd.PowerAmdCpu.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the measure process if started. A signal is send to the logging process to stop measurements</p> Source code in <code>ea2p/src/amd.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stop the measure process if started. A signal is send to the logging process to stop measurements\n    \"\"\"\n    self.logging_process.send_signal(signal.SIGINT)\n    self.logging_process = None\n</code></pre>"},{"location":"api_documentation/api_documentation/","title":"Welcome to EA2P API reference Documentation","text":""},{"location":"api_documentation/intel/","title":"ea2p.intel","text":""},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel","title":"PowerClientIntel","text":"<pre><code>PowerClientIntel()\n</code></pre> <p>               Bases: <code>PowerLinux</code></p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.cpu_sub_doms = self.get_cpu_sub_domains()\n    self.power_draws = []\n    self.record = {}\n    self.start_time = None\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.__get_cpu_domains","title":"__get_cpu_domains  <code>staticmethod</code>","text":"<pre><code>__get_cpu_domains()\n</code></pre> <p>Get CPU domains from entries in POWERLOG_PATH_LINUX.</p> <p>Returns: - List of tuples containing CPU domain information.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>@staticmethod\ndef __get_cpu_domains():\n    \"\"\"\n    Get CPU domains from entries in POWERLOG_PATH_LINUX.\n\n    Returns:\n    - List of tuples containing CPU domain information.\n    \"\"\"\n    cpu_doms = []\n    for entry in os.scandir(POWERLOG_PATH_LINUX):\n        if (entry.is_dir() and (\"intel-rapl:\" in entry.name)):\n            dom = (entry.name.split(\":\"))[1]\n            file = Path(READ_RAPL_PATH.format(int(dom))) / RAPL_DEVICENAME_FILE\n            cpu_doms.append((int(dom), file.read_text().replace('\\n','')))\n    return cpu_doms\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.__get_cpu_ids","title":"__get_cpu_ids  <code>staticmethod</code>","text":"<pre><code>__get_cpu_ids()\n</code></pre> <p>Get CPU identifiers from files in CPU_IDS_DIR.</p> <p>Returns: - List of CPU identifiers.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>@staticmethod\ndef __get_cpu_ids():\n    \"\"\"\n    Get CPU identifiers from files in CPU_IDS_DIR.\n\n    Returns:\n    - List of CPU identifiers.\n    \"\"\"\n    cpu_ids = []\n    for filename in glob.glob(CPU_IDS_DIR):\n        with open(filename, \"r\") as f:\n            package_id = int(f.read())\n        if package_id not in cpu_ids:\n            cpu_ids.append(package_id)\n    return cpu_ids\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.__get_powerlog_file","title":"__get_powerlog_file","text":"<pre><code>__get_powerlog_file()\n</code></pre> <p>Retrieve the log file where PowerLog logs are written.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __get_powerlog_file(self):\n    \"\"\"\n    Retrieve the log file where PowerLog logs are written.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.append_energy_usage","title":"append_energy_usage","text":"<pre><code>append_energy_usage()\n</code></pre> <p>Append CPU energy usage. Returns:         Dictionary containing CPU energy usage.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def append_energy_usage(self):\n    \"\"\"\n    Append CPU energy usage.\n    Returns:\n    \tDictionary containing CPU energy usage.\n    \"\"\"\n    energy_usage = {}\n    energies = [self.get_cpu_energy_package(cpu_domain, cpu_sub_domain)\n            for cpu_domain, cpu_sub_domain, subdom_name in self.cpu_sub_doms]\n\n    energies_2 = [self.get_cpu_energy(dom) for dom, name in self.cpu_doms]\n    i = 0\n    for cpu_domain, cpu_sub_domain, subdom_name in self.cpu_sub_doms:\n        energy_usage[subdom_name] = energies[i] / JOULE_TO_WATT\n        i += 1\n    i = 0\n    for dom, name in self.cpu_doms:\n        energy_usage[name] = energies_2[i] / JOULE_TO_WATT\n        i += 1\n\n    return energy_usage\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.get_cpu_energy","title":"get_cpu_energy","text":"<pre><code>get_cpu_energy(cpu)\n</code></pre> <p>Get CPU energy usage for a specific CPU.</p> <p>Parameters:</p> <ul> <li> <code>cpu</code>               (<code>int</code>)           \u2013            <p>CPU identifier.</p> </li> </ul> <p>Returns:         Energy usage for the specified CPU.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def get_cpu_energy(self, cpu):\n    \"\"\"\n    Get CPU energy usage for a specific CPU.\n\n    Parameters:\n    \tcpu (int): CPU identifier.\n    Returns:\n    \tEnergy usage for the specified CPU.\n    \"\"\"\n    cpu_energy_file = Path(READ_RAPL_PATH.format(cpu)) / RAPL_ENERGY_FILE\n    energy = int(cpu_energy_file.read_text())\n    return energy\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.get_cpu_energy_package","title":"get_cpu_energy_package","text":"<pre><code>get_cpu_energy_package(domain, sub_domain)\n</code></pre> <p>Get CPU energy usage for a specific sub-domain.</p> <p>Parameters:</p> <ul> <li> <code>domain</code>               (<code>int</code>)           \u2013            <p>CPU domain.</p> </li> <li> <code>sub_domain</code>               (<code>int</code>)           \u2013            <p>CPU sub-domain.</p> </li> </ul> <p>Returns:         Energy usage for the specified CPU sub-domain.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def get_cpu_energy_package(self, domain, sub_domain):\n    \"\"\"\n    Get CPU energy usage for a specific sub-domain.\n\n    Parameters:\n    \tdomain (int): CPU domain.\n    \tsub_domain (int): CPU sub-domain.\n    Returns:\n    \tEnergy usage for the specified CPU sub-domain.\n    \"\"\"\n    energy_file = (\n        Path(READ_RAPL_PATH.format(domain))\n        / (RAPL_PATH_SUB_DOMS.format(domain, sub_domain))\n        / RAPL_ENERGY_FILE\n    )\n    energy = int(energy_file.read_text())\n    return energy\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.get_cpu_sub_domains","title":"get_cpu_sub_domains","text":"<pre><code>get_cpu_sub_domains()\n</code></pre> <p>Get the list of CPU sub-domains. Returns:         List of tuples containing CPU domain information.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def get_cpu_sub_domains(self):\n    \"\"\"\n    Get the list of CPU sub-domains.\n    Returns:\n    \tList of tuples containing CPU domain information.\n    \"\"\"\n    cpu_sub_doms = []\n    for dom, name in self.cpu_doms:\n        dom_paths = glob.glob(\n            READ_RAPL_PATH.format(dom)\n            + RAPL_PATH_SUB_DOMS.format(dom, \"*\")\n            + RAPL_DEVICENAME_FILE\n        )\n        for i, file in enumerate(dom_paths):\n            file = Path(file)\n            subdom_name = file.read_text().replace('\\n','')\n            cpu_sub_doms.append((dom, i, subdom_name))\n    return cpu_sub_doms\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Starts the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def start(self):\n    \"\"\"\n    Starts the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stops the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stops the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerClientIntel.stop_thread","title":"stop_thread","text":"<pre><code>stop_thread()\n</code></pre> <p>Stops the recording thread.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop_thread(self):\n    \"\"\"\n    Stops the recording thread.\n    \"\"\"\n    self.thread.do_run = False\n    self.thread.join()\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel","title":"PowerServerIntel","text":"<pre><code>PowerServerIntel()\n</code></pre> <p>               Bases: <code>PowerLinux</code></p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.dram_ids = self.__get_drams_ids()\n    self.power_draws = []\n    self.record = {}\n    self.start_time = None\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.__get_cpu_domains","title":"__get_cpu_domains  <code>staticmethod</code>","text":"<pre><code>__get_cpu_domains()\n</code></pre> <p>Get CPU domains from entries in POWERLOG_PATH_LINUX.</p> <p>Returns: - List of tuples containing CPU domain information.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>@staticmethod\ndef __get_cpu_domains():\n    \"\"\"\n    Get CPU domains from entries in POWERLOG_PATH_LINUX.\n\n    Returns:\n    - List of tuples containing CPU domain information.\n    \"\"\"\n    cpu_doms = []\n    for entry in os.scandir(POWERLOG_PATH_LINUX):\n        if (entry.is_dir() and (\"intel-rapl:\" in entry.name)):\n            dom = (entry.name.split(\":\"))[1]\n            file = Path(READ_RAPL_PATH.format(int(dom))) / RAPL_DEVICENAME_FILE\n            cpu_doms.append((int(dom), file.read_text().replace('\\n','')))\n    return cpu_doms\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.__get_cpu_energy","title":"__get_cpu_energy","text":"<pre><code>__get_cpu_energy(cpu)\n</code></pre> <p>Get CPU energy usage for a specific CPU.</p> <p>Parameters:</p> <ul> <li> <code>cpu</code>               (<code>int</code>)           \u2013            <p>CPU identifier.</p> </li> </ul> <p>Returns:         Energy usage for the specified CPU.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def __get_cpu_energy(self, cpu):\n    \"\"\"\n    Get CPU energy usage for a specific CPU.\n\n    Parameters:\n    \tcpu (int): CPU identifier.\n    Returns:\n    \tEnergy usage for the specified CPU.\n    \"\"\"\n    cpu_energy_file = Path(READ_RAPL_PATH.format(cpu)) / RAPL_ENERGY_FILE\n    energy = int(cpu_energy_file.read_text())\n    return energy\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.__get_cpu_ids","title":"__get_cpu_ids  <code>staticmethod</code>","text":"<pre><code>__get_cpu_ids()\n</code></pre> <p>Get CPU identifiers from files in CPU_IDS_DIR.</p> <p>Returns: - List of CPU identifiers.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>@staticmethod\ndef __get_cpu_ids():\n    \"\"\"\n    Get CPU identifiers from files in CPU_IDS_DIR.\n\n    Returns:\n    - List of CPU identifiers.\n    \"\"\"\n    cpu_ids = []\n    for filename in glob.glob(CPU_IDS_DIR):\n        with open(filename, \"r\") as f:\n            package_id = int(f.read())\n        if package_id not in cpu_ids:\n            cpu_ids.append(package_id)\n    return cpu_ids\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.__get_dram_energy","title":"__get_dram_energy","text":"<pre><code>__get_dram_energy(cpu, dram)\n</code></pre> <p>Get DRAM energy usage for a specific CPU and DRAM.</p> <p>Parameters:</p> <ul> <li> <code>cpu</code>               (<code>int</code>)           \u2013            <p>CPU identifier.</p> </li> <li> <code>dram</code>               (<code>int</code>)           \u2013            <p>DRAM identifier.</p> </li> </ul> <p>Returns:         Energy usage for the specified DRAM.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def __get_dram_energy(self, cpu, dram):\n    \"\"\"\n    Get DRAM energy usage for a specific CPU and DRAM.\n\n    Parameters:\n    \tcpu (int): CPU identifier.\n    \tdram (int): DRAM identifier.\n    Returns:\n    \tEnergy usage for the specified DRAM.\n    \"\"\"\n    dram_energy_file = (\n        Path(READ_RAPL_PATH.format(cpu))\n        / (RAPL_DRAM_PATH.format(cpu, dram))\n        / RAPL_ENERGY_FILE\n    )\n    energy = int(dram_energy_file.read_text())\n    return energy\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.__get_drams_ids","title":"__get_drams_ids","text":"<pre><code>__get_drams_ids()\n</code></pre> <p>Get the list of DRAM IDs. Returns:         List of tuples containing CPU and DRAM IDs.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def __get_drams_ids(self):\n    \"\"\"\n    Get the list of DRAM IDs.\n    Returns:\n    \tList of tuples containing CPU and DRAM IDs.\n    \"\"\"\n    dram_id_list = []\n    for cpu in self.cpu_ids:\n        dram_paths = glob.glob(\n            READ_RAPL_PATH.format(cpu)\n            + RAPL_DRAM_PATH.format(cpu, \"*\")\n            + RAPL_DEVICENAME_FILE\n        )\n        for i, dram_file in enumerate(dram_paths):\n            dram_file = Path(dram_file)\n            if \"dram\" in dram_file.read_text():\n                dram_id_list.append((cpu, i))\n                break\n    return dram_id_list\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.__get_powerlog_file","title":"__get_powerlog_file","text":"<pre><code>__get_powerlog_file()\n</code></pre> <p>Retrieve the log file where PowerLog logs are written.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __get_powerlog_file(self):\n    \"\"\"\n    Retrieve the log file where PowerLog logs are written.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.append_energy_usage","title":"append_energy_usage","text":"<pre><code>append_energy_usage()\n</code></pre> <p>Append CPU and memory energy usage. Returns:         Dictionary containing CPU and memory energy usage.</p> Source code in <code>ea2p/src/intel.py</code> <pre><code>def append_energy_usage(self):\n    \"\"\"\n    Append CPU and memory energy usage.\n    Returns:\n    \tDictionary containing CPU and memory energy usage.\n    \"\"\"\n    energy_usage = {}\n    energy_usage[\"energy_cpu\"] = sum([self.__get_cpu_energy(cpu_id) for cpu_id in self.cpu_ids]) / JOULE_TO_WATT\n    energy_usage[\"energy_memory\"] = sum([self.__get_dram_energy(cpu_id, dram_id) for cpu_id, dram_id in self.dram_ids ]) / JOULE_TO_WATT\n    return energy_usage\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Starts the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def start(self):\n    \"\"\"\n    Starts the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stops the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stops the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/intel/#ea2p.src.intel.PowerServerIntel.stop_thread","title":"stop_thread","text":"<pre><code>stop_thread()\n</code></pre> <p>Stops the recording thread.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop_thread(self):\n    \"\"\"\n    Stops the recording thread.\n    \"\"\"\n    self.thread.do_run = False\n    self.thread.join()\n</code></pre>"},{"location":"api_documentation/nvidia/","title":"ea2p.nvidia","text":""},{"location":"api_documentation/nvidia/#ea2p.src.nvidia.PowerNvidia","title":"PowerNvidia","text":"<pre><code>PowerNvidia()\n</code></pre> <p>Class for monitoring Nvidia GPU power usage</p> Source code in <code>ea2p/src/nvidia.py</code> <pre><code>def __init__(self):\n    # Query drivers for the first time to avoid \"Unknown\" in the result. This also test the availability and working for Nvidia's drivers\n    try:\n        subprocess.check_output(\"nvidia-smi --query-gpu=power.draw --format=csv\", shell=True)\n    except subprocess.CalledProcessError:\n        print(\"Error querying GPU power. Check if 'nvidia-smi' is installed and available.\")\n</code></pre>"},{"location":"api_documentation/nvidia/#ea2p.src.nvidia.PowerNvidia.append_energy_usage","title":"append_energy_usage","text":"<pre><code>append_energy_usage()\n</code></pre> <p>Append Nvidia GPU energy usage to dict containing sampling power measurements.</p> <p>Returns: - Dictionary containing GPU power usage per GPU devices.</p> Source code in <code>ea2p/src/nvidia.py</code> <pre><code>def append_energy_usage(self):\n    \"\"\"\n    Append Nvidia GPU energy usage to dict containing sampling power measurements.\n\n    Returns:\n    - Dictionary containing GPU power usage per GPU devices.\n    \"\"\"\n\n    cmd = \"nvidia-smi --query-gpu=power.draw --format=csv\"\n    energy_usage = subprocess.check_output(cmd, shell=True)\n    energy_usage = energy_usage.decode(\"utf-8\").replace(\" W\", \"\")\n    energy_usage = energy_usage.split(\"\\n\")[1:-1]\n    #print(energy_usage)\n    energy = {\"GPU \" + str(i): (float(energy_usage[i])) for i in range(len(energy_usage))}\n\n    return energy\n</code></pre>"},{"location":"api_documentation/power/","title":"ea2p.power","text":""},{"location":"api_documentation/power/#ea2p.src.power.PowerProfiler","title":"PowerProfiler","text":"<pre><code>PowerProfiler()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>This abstract class PowerProfiler defines two abstract methods \"start\" and \"stop\" which need to be implemented by any subclass inheriting from it.  These methods will handle the actual start and stop operations for profiling power consumption, respectively depending on device drivers or registries access.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __init__(self):\n    self.record = {}\n    self.thread = None\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerProfiler.__get_powerlog_file","title":"__get_powerlog_file","text":"<pre><code>__get_powerlog_file()\n</code></pre> <p>Retrieve the log file where PowerLog logs are written.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __get_powerlog_file(self):\n    \"\"\"\n    Retrieve the log file where PowerLog logs are written.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerProfiler.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Starts the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def start(self):\n    \"\"\"\n    Starts the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerProfiler.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stops the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stops the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerProfiler.stop_thread","title":"stop_thread","text":"<pre><code>stop_thread()\n</code></pre> <p>Stops the recording thread.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop_thread(self):\n    \"\"\"\n    Stops the recording thread.\n    \"\"\"\n    self.thread.do_run = False\n    self.thread.join()\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux","title":"PowerLinux","text":"<pre><code>PowerLinux()\n</code></pre> <p>               Bases: <code>PowerProfiler</code></p> <p>A class \"PowerLinux\" which inherits from \"PowerProfiler\" for energy/power profiling under Linux systems. We have two statics methods to get the RAPL domains and subsdomains on the Linux system for Intel CPUs.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.cpu_ids = self.__get_cpu_ids()\n    self.cpu_doms = self.__get_cpu_domains()\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux.__get_cpu_domains","title":"__get_cpu_domains  <code>staticmethod</code>","text":"<pre><code>__get_cpu_domains()\n</code></pre> <p>Get CPU domains from entries in POWERLOG_PATH_LINUX.</p> <p>Returns: - List of tuples containing CPU domain information.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>@staticmethod\ndef __get_cpu_domains():\n    \"\"\"\n    Get CPU domains from entries in POWERLOG_PATH_LINUX.\n\n    Returns:\n    - List of tuples containing CPU domain information.\n    \"\"\"\n    cpu_doms = []\n    for entry in os.scandir(POWERLOG_PATH_LINUX):\n        if (entry.is_dir() and (\"intel-rapl:\" in entry.name)):\n            dom = (entry.name.split(\":\"))[1]\n            file = Path(READ_RAPL_PATH.format(int(dom))) / RAPL_DEVICENAME_FILE\n            cpu_doms.append((int(dom), file.read_text().replace('\\n','')))\n    return cpu_doms\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux.__get_cpu_ids","title":"__get_cpu_ids  <code>staticmethod</code>","text":"<pre><code>__get_cpu_ids()\n</code></pre> <p>Get CPU identifiers from files in CPU_IDS_DIR.</p> <p>Returns: - List of CPU identifiers.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>@staticmethod\ndef __get_cpu_ids():\n    \"\"\"\n    Get CPU identifiers from files in CPU_IDS_DIR.\n\n    Returns:\n    - List of CPU identifiers.\n    \"\"\"\n    cpu_ids = []\n    for filename in glob.glob(CPU_IDS_DIR):\n        with open(filename, \"r\") as f:\n            package_id = int(f.read())\n        if package_id not in cpu_ids:\n            cpu_ids.append(package_id)\n    return cpu_ids\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux.__get_powerlog_file","title":"__get_powerlog_file","text":"<pre><code>__get_powerlog_file()\n</code></pre> <p>Retrieve the log file where PowerLog logs are written.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __get_powerlog_file(self):\n    \"\"\"\n    Retrieve the log file where PowerLog logs are written.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Starts the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def start(self):\n    \"\"\"\n    Starts the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stops the recording process.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stops the recording process.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/power/#ea2p.src.power.PowerLinux.stop_thread","title":"stop_thread","text":"<pre><code>stop_thread()\n</code></pre> <p>Stops the recording thread.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop_thread(self):\n    \"\"\"\n    Stops the recording thread.\n    \"\"\"\n    self.thread.do_run = False\n    self.thread.join()\n</code></pre>"},{"location":"api_documentation/ram/","title":"ea2p.ram","text":""},{"location":"api_documentation/ram/#ea2p.src.ram.PowerRam","title":"PowerRam","text":"<pre><code>PowerRam()\n</code></pre>"},{"location":"api_documentation/ram/#ea2p.src.ram.PowerRam--powerram","title":"PowerRam","text":"<p>Python classes monitoring RAM's power usage.  We used an analytical approach to calibrate RAM power by combining information of DIMM nomminal Power for each DDR memory module version, number of DIMM slots in use and the memory footprint during application execution</p>"},{"location":"api_documentation/ram/#ea2p.src.ram.PowerRam--powerram","title":"PowerRam","text":"<p>Python classes monitoring RAM's power usage.</p> Source code in <code>ea2p/src/ram.py</code> <pre><code>def __init__(self):\n\t\"\"\"\n\n\tPowerRam\n\t---------------\n\n\tPython classes monitoring RAM's power usage.\n\t\"\"\"\n\tself.ram_power = self.get_memory_power()\n\tself.number_slots = self.get_number_slots()\n</code></pre>"},{"location":"api_documentation/ram/#ea2p.src.ram.PowerRam.append_energy_usage","title":"append_energy_usage","text":"<pre><code>append_energy_usage()\n</code></pre> <p>We used an analytical approach to calibrate RAM power by combining information of DIMM nomminal Power for each DDR memory module version, number of DIMM slots in use and the memory footprint during application execution</p> Source code in <code>ea2p/src/ram.py</code> <pre><code>def append_energy_usage(self):\n\t\"\"\"\n\tWe used an analytical approach to calibrate RAM power by combining information of DIMM nomminal Power for each DDR memory module version, number of DIMM slots in use and the memory footprint during application execution\n\t\"\"\"\n\tram_usage = psutil.virtual_memory()\n\tram_percent = ram_usage[2]\n\tTHRESHOLD0 = 5\n\tTHRESHOLD1 = 10\n\tTHRESHOLD2 = 25\n\tTHRESHOLD3 = 50\n\tTHRESHOLD4 = 70\n\tif ram_usage[2] &lt;= THRESHOLD0 :\n\t\tram_percent = 35\n\telif ram_usage[2] &lt;= THRESHOLD1 :\n\t\tram_percent = 65\n\telif ram_usage[2] &lt;= THRESHOLD2 :\n\t\tram_percent = 70\n\telif ram_usage[2] &lt;= THRESHOLD3 :\n\t\tram_percent = 75\n\telif ram_usage[2] &lt;= THRESHOLD4 :\n\t\tram_percent = 80\n\telse :\n\t\tram_percent = 85\n\n\tenergy_usage = {\"dram\":(self.ram_power * self.number_slots * ram_percent / 100)}\n\t#print(energy_usage)\n\treturn energy_usage\n</code></pre>"},{"location":"api_documentation/wrapper/","title":"ea2p.wrapper","text":""},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper","title":"PowerWrapper","text":"<pre><code>PowerWrapper(config_file='config_energy.json')\n</code></pre> <p>               Bases: <code>PowerProfiler</code></p> <p>A wrapper class for energy monitoring across various devices including CPU, GPU, and DRAM.</p> <p>This class facilitates aggregation, coordination of execution, and formatting of the output  for measured energy values from different devices.</p> <p>Attributes:</p> <ul> <li> <code>energy_unit</code>               (<code>str</code>)           \u2013            <p>The energy unit for the final result report (e.g., 'J' for joule, 'Wh' for Watt-hour, 'kWh' for kilowatt-hour).</p> </li> <li> <code>power_devices</code>               (<code>str</code>)           \u2013            <p>A string containing the list of specified devices to profile.</p> </li> <li> <code>record</code>               (<code>dict</code>)           \u2013            <p>A dictionary to contain the recorded measurements.</p> </li> <li> <code>thread</code>               (<code>Thread</code>)           \u2013            <p>The main Python Thread instance that coordinates measurement from other subprocess threads.</p> </li> <li> <code>interval</code>               (<code>float</code>)           \u2013            <p>A float value to specify the sampling frequency of measurements.</p> </li> <li> <code>power_objects</code>               (<code>list</code>)           \u2013            <p>A list that stores different instances of measurements classes for various devices.</p> </li> <li> <code>intel</code>               (<code>bool</code>)           \u2013            <p>A boolean value indicating the presence (True) or absence (False) of an Intel CPU.</p> </li> <li> <code>amd</code>               (<code>bool</code>)           \u2013            <p>A boolean value indicating the presence (True) or absence (False) of an AMD CPU.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>start</code>             \u2013              <p>Begins monitoring energy usage from the specified list of devices.</p> </li> <li> <code>stop</code>             \u2013              <p>Stops the energy monitoring process and agregate results.</p> </li> <li> <code>get_power_consumption</code>             \u2013              <p>Continuously get energy usage from all specified power monitoring instances.</p> </li> <li> <code>__set_power</code>             \u2013              <p>Create instances of power monitoring classes based on the specified power devices (\"e.g., \"cpu, Ram, gpu\").</p> </li> <li> <code>get_all_power</code>             \u2013              <p>Get energy usage from all specified power monitoring instances at a specific sampling period.</p> </li> </ul> <p>Initialize the PowerWrapper instance.</p> <p>Parameters:</p> <ul> <li> <code>config_file</code>               (<code>str</code>, default:                   <code>'config_energy.json'</code> )           \u2013            <p>Path to the configuration file to use. If not provided, the default energy unit is Watt-hour with sampling frequency of one(1) second and measurements are across both CPU GPU and RAM</p> </li> </ul> Source code in <code>ea2p/src/wrapper.py</code> <pre><code>def __init__(self, config_file=\"config_energy.json\"):\n    \"\"\"\n    Initialize the PowerWrapper instance.\n\n    Parameters:\n    \tconfig_file (str): Path to the configuration file to use. If not provided, the default energy unit is Watt-hour with sampling frequency of one(1) second and measurements are across both CPU GPU and RAM\n    \"\"\"\n    super().__init__()\n\n    with open(config_file, 'r') as file:\n        config = json.load(file)\n\n    self.power_devices = config.get('devices_list').lower()\n    self.energy_unit = config.get('energy_unit').lower()\n    self.record = {}\n    self.thread = None\n    self.interval = config.get('sampling_freq')\n    self.amd = False\n    self.intel = False\n    self.intel_ram = False\n    self.power_objects = self.__set_power(self.power_devices)\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.__get_powerlog_file","title":"__get_powerlog_file","text":"<pre><code>__get_powerlog_file()\n</code></pre> <p>Retrieve the log file where PowerLog logs are written.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def __get_powerlog_file(self):\n    \"\"\"\n    Retrieve the log file where PowerLog logs are written.\n    \"\"\"\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.__set_power","title":"__set_power","text":"<pre><code>__set_power(power_devices)\n</code></pre> <p>Create instances of power monitoring classes based on the specified power devices.</p> <p>Parameters:</p> <ul> <li> <code>power_devices</code>               (<code>str</code>)           \u2013            <p>A comma-separated string specifying the power devices to monitor.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>power_objects</code> (              <code>list</code> )          \u2013            <p>A list of power monitoring instances, respectivelly for each device in the devices list.</p> </li> </ul> Source code in <code>ea2p/src/wrapper.py</code> <pre><code>def __set_power(self, power_devices):\n    \"\"\"\n    Create instances of power monitoring classes based on the specified power devices.\n\n    Parameters:\n    \tpower_devices (str): A comma-separated string specifying the power devices to monitor.\n\n    Returns:\n    \tpower_objects (list): A list of power monitoring instances, respectivelly for each device in the devices list.\n    \"\"\"\n    cpu_brand = \"\"\n    power_objects = list()\n    if (\"cpu\" not in power_devices) and (\"gpu\" not in power_devices) and (\"ram\" not in power_devices):\n        raise ValueError(\"Please specify at least one device type to monitor in [cpu, gpu, ram] \")\n\n    if \"cpu\" in power_devices:\n        cpu_brand = cpuinfo.get_cpu_info()['brand_raw']\n        if \"Core(TM)\" in cpu_brand:\n            self.intel = True\n            self.intel_power = PowerClientIntel()\n        elif \"Xeon\" in cpu_brand:\n            self.intel = True\n            self.intel_power = PowerServerIntel()\n        elif \"AMD\" in cpu_brand:\n            self.amd_power = PowerAmdCpu()\n            self.amd = True\n            LOGGER.info(\"AMD found\")\n        else:\n            raise SystemError(\n                \"Unable to detect the CPU informations of your system. \"\n                \"Try to remove CPU in your config_energy.json file \"\n                \"to monitor other components like RAM or GPU energies \"\n            )\n\n    if \"gpu\" in power_devices:\n        try:\n            subprocess.check_output('nvidia-smi')\n            power_objects.append(PowerNvidia())\n        except Exception:\n            pass\n\n        try:\n            subprocess.check_output('rocminfo')\n            power_objects.append(PowerAmdGpu())\n        except Exception:\n            pass\n\n    if \"ram\" in power_devices and not (\"Xeon\" in cpu_brand):\n        power_objects.append(PowerRam())\n\n    return power_objects\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.get_all_power","title":"get_all_power","text":"<pre><code>get_all_power(power_objects)\n</code></pre> <p>Get energy usage from all specified power monitoring instances at a specific sampling period.</p> <p>Parameters:</p> <ul> <li> <code>power_objects</code>               (<code>list</code>)           \u2013            <p>List of power monitoring instances, respectivelly for each device in the devices list.</p> </li> </ul> Source code in <code>ea2p/src/wrapper.py</code> <pre><code>def get_all_power(self, power_objects):\n    \"\"\"\n    Get energy usage from all specified power monitoring instances at a specific sampling period.\n\n    Parameters:\n    \tpower_objects (list): List of power monitoring instances, respectivelly for each device in the devices list.\n    \"\"\"\n    energy_usage = {}\n    for obj in power_objects:\n        energy_usage.update(obj.append_energy_usage())\n\n    self.power_draws.append(energy_usage)\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.get_power_consumption","title":"get_power_consumption","text":"<pre><code>get_power_consumption(power_objects)\n</code></pre> <p>Continuously get energy usage from all specified power monitoring instances.</p> <p>Parameters:</p> <ul> <li> <code>power_objects</code>               (<code>list</code>)           \u2013            <p>List of power monitoring instances, respectivelly for each device in the devices list.</p> </li> </ul> Source code in <code>ea2p/src/wrapper.py</code> <pre><code>def get_power_consumption(self, power_objects):\n    \"\"\"\n    Continuously get energy usage from all specified power monitoring instances.\n\n    Parameters:\n    \tpower_objects (list): List of power monitoring instances, respectivelly for each device in the devices list.\n    \"\"\"\n    if self.amd:\n        self.amd_power.start()\n\n    if power_objects and self.intel:\n        self.get_all_power(power_objects)\n        while getattr(self.thread, \"do_run\", True):\n            self.get_all_power(power_objects)\n            self.intel_record.append(self.intel_power.append_energy_usage())\n            time.sleep(self.interval)\n        self.get_all_power(power_objects)\n    elif power_objects:\n        self.get_all_power(power_objects)\n        while getattr(self.thread, \"do_run\", True):\n            self.get_all_power(power_objects)\n            time.sleep(self.interval)\n        self.get_all_power(power_objects)\n    elif self.intel:\n        while getattr(self.thread, \"do_run\", True):\n            self.intel_record.append(self.intel_power.append_energy_usage())\n            time.sleep(self.interval)\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.start","title":"start","text":"<pre><code>start()\n</code></pre> <p>Start the power monitoring process. This function creates the main threads to coordinate subprocesses that profile energy/power on different devices.</p> <p>This function initializes threads to profile power consumption on various devices concurrently. Each thread corresponds to a specific device and is responsible for initiating the power profiling process for that device. The devices are specified in a list of device names. Power profiling subprocesses for each device are coordinated through separate threads to ensure parallel execution.</p> Example <p>PowerWrapper wrapper = PowerWrapper() wrapper.start()</p> Note <p>This function assumes the existence of a class or function responsible for profiling power consumption on individual devices. The actual power profiling logic should be implemented within the respective threads or subprocesses.</p> Source code in <code>ea2p/src/wrapper.py</code> <pre><code>def start(self):\n    \"\"\"\n    Start the power monitoring process. This function creates the main threads to coordinate subprocesses\n    that profile energy/power on different devices.\n\n    This function initializes threads to profile power consumption on various devices concurrently. Each thread\n    corresponds to a specific device and is responsible for initiating the power profiling process for that device.\n    The devices are specified in a list of device names. Power profiling subprocesses for each device are\n    coordinated through separate threads to ensure parallel execution.\n\n    Example:\n        PowerWrapper wrapper = PowerWrapper()\n        wrapper.start()\n\n    Note:\n        This function assumes the existence of a class or function responsible for profiling power consumption\n        on individual devices. The actual power profiling logic should be implemented within the respective\n        threads or subprocesses.\n    \"\"\"\n    LOGGER.info(\"Starting CPU power monitoring...\")\n    self.start_time = time.time()\n    self.power_draws = []\n    self.intel_record = []\n    self.record = {}\n    if self.thread and self.thread.is_alive():\n        self.stop_thread()\n        self.thread.join()\n    self.thread = threading.Thread(target=self.get_power_consumption, args=(self.power_objects,))\n    # self.thread.do_run = True\n    self.thread.start()\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> <p>Stop the power monitoring process and collect/aggregate the final power consumption data.</p> <p>This function stops the power monitoring process by terminating the main threads responsible for coordinating the profiling of energy/power consumption on various devices. It ensures the orderly shutdown of all power profiling subprocesses and releases any associated resources. Additionally, it collects and aggregates data from the different devices' profiling, allowing for further analysis or reporting.</p> Example <p>PowerWrapper wrapper = PowerWrapper() wrapper.stop()</p> Source code in <code>ea2p/src/wrapper.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Stop the power monitoring process and collect/aggregate the final power consumption data.\n\n    This function stops the power monitoring process by terminating the main threads responsible for coordinating\n    the profiling of energy/power consumption on various devices. It ensures the orderly shutdown of all\n    power profiling subprocesses and releases any associated resources. Additionally, it collects and aggregates\n    data from the different devices' profiling, allowing for further analysis or reporting.\n\n    Example:\n        PowerWrapper wrapper = PowerWrapper()\n        wrapper.stop()\n\n    \"\"\"\n    if self.thread and self.thread.is_alive():\n        # self.stop_thread()\n        self.thread.do_run = False\n        self.thread.join()\n\n    end_time = time.time()\n\n    usages = pd.DataFrame(self.power_draws)\n    cpu_energy = pd.DataFrame()\n    usages = usages.sum().to_frame().T\n    usages = usages * self.interval / 3600          # convert watt to watt-hour for RAM and GPU especially\n\n    if self.amd:\n        self.amd_power.stop()\n        cpu_energy = self.amd_power.parse_log()\n        usages = pd.concat([cpu_energy, usages], axis=1)\n\n    if self.intel:\n        self.intel_record.append(self.intel_power.append_energy_usage())\n\n        cpu_energy = pd.DataFrame(self.intel_record)\n        cpu_energy = cpu_energy.diff().fillna(cpu_energy)\n        cpu_energy = cpu_energy.iloc[1:, :]\n        cpu_energy = cpu_energy.mask(cpu_energy.lt(0)).ffill().fillna(0)\n        cpu_energy = cpu_energy.sum().to_frame().T\n        usages = pd.concat([cpu_energy, usages], axis=1)\n\n    if self.energy_unit==\"j\":\n        usages = usages * WH_TO_JOULE\n    elif self.energy_unit==\"wh\":\n        pass\n    elif self.energy_unit==\"kwh\":\n        usages = usages * WH_TO_KW\n    else :\n        LOGGER.info(\"WARRNING : The specified energy unit is not supported. \"\n                    \"Please try to specify J or WH or KWH in the energy config file. \"\n                    \"Otherwise, the default unit of WH is used\")\n\n\n    usages[TOTAL_CPU_TIME] = end_time - self.start_time\n    self.record = usages.round(5)\n</code></pre>"},{"location":"api_documentation/wrapper/#ea2p.src.wrapper.PowerWrapper.stop_thread","title":"stop_thread","text":"<pre><code>stop_thread()\n</code></pre> <p>Stops the recording thread.</p> Source code in <code>ea2p/src/power.py</code> <pre><code>def stop_thread(self):\n    \"\"\"\n    Stops the recording thread.\n    \"\"\"\n    self.thread.do_run = False\n    self.thread.join()\n</code></pre>"}]}